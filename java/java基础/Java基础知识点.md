# Java 知识点

## Java 序列化

把一个对象的状态写入到一个 byte 流中，并且可以从其他地方把该 byte 流的数据读出，重新构造一个相同的对象。

实现 Serializable 接口。

## 类加载过程

### 过程

* JVM 启动，运行 bootstrap classloader（由 C++ 实现，不是ClassLoader子类），加载 java 核心 API（ExtClassLoader 和 AppClassLoader 也被加载）
* ExtClassLoader。加载扩展 API（/lib/ext）
* AppClassLoader。加载 classpath 目录下的 class，以及用户自定义的 class
* Custom ClassLoader。属于应用程序根据自身需要自定义的ClassLoader

![类加载](https://raw.githubusercontent.com/onlylemi/res/master/java_classloader.png)

### 加载方式

双亲委托模式。现委托它的父亲 ClassLoader 进行加载，只有当父亲无法加载时，才会自己加载。

* 避免重复加载
* 安全。避免随时动态的替代 Java 核心 api 中定义的类型

```
// 执行以下命令，JVM 会把 .class 加载到内存中，形成一个 class 对象
java HelloWorld
```

JVM 加载类

* 装载。找到 class 文件，读入 JVM
* 连接
    * 验证。验证 class 是否合规格
    * 准备。为变量分配内存，同时设置默认值
    * 解析。
* 初始化。为变量赋予正确的初始值

## ClassLoader.loadClass() 与 Class.forName() 区别

### 相同

两者都会将用户指定的类加载到内存中，供用户使用

### 不同

Class.forName 方法有要不要初始 static 变量的参数，而 ClassLoader.loadClass() 没有；

> JDBC 驱动加载，DriverMannages
Class.forName("...");

## String、StringBuffer、StringBulder 区别

* String 字符串常量，不可变得对象，对其进行改变的同时会在串池中新生成一个 String 对象，进而指向这个对象。耗内存
* StringBuffer 字符串变量（线程安全）
* StringBulder 字符串变量（线程不安全）

## synchronized 和 Lock 的异同

* synchronized
  在 JVM 层面上实现的。在锁定时如果方法块抛出异常，JVM 会自动将锁释放掉，不会因为出了异常没有释放锁造成线程死锁。
* Lock
  是通过代码实现的。出现异常时必须在 finally 将锁释放掉，否则将会引起死锁。

在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized 是很合适的。但是当同步非常激烈的时候，synchronized 的性能一下子能下降好几十倍。而 Lock 确还能维持常态。 

## 线程

* join() 使异步执行变成同步执行

## sleep 和 wait 的区别

* sleep
  该方法是属于Thread类中。程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。且线程不会释放对象锁。
* wait
  属于Object类中的。线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备

参考：http://www.cnblogs.com/hongten/p/hongten_java_sleep_wait.html

## 内存回收

垃圾：不在被引用的对象

栈：存放简单数据类型变量、引用数据类型变量名、实例的首地址
堆：存放引用数据类型的实例

Java 的垃圾回收机制是 Java 虚拟机 JVM 提供的能力，用于在空闲时间以不定时的方式动态回收无任何引用的对象占据的内存空间。
```java
System.gc()
Runtime.getRuntime().gc()  
```
上面的方法调用时用于显式通知JVM可以进行一次垃圾回收，但真正垃圾回收机制具体在什么时间点开始发生动作这同样是不可预料的，这和抢占式的线程在发生作用时的原理一样。

参考：http://www.cnblogs.com/ywl925/p/3925637.html

## I/O

![I/O类图](https://raw.githubusercontent.com/onlylemi/res/master/java_io.jpg)

* Piped... 管道流。主要可以进行两个线程之间的通信

## NIO

I/O：面向流。系统一次一个字节地处理数据
NIO：面向块。系统以块的形式处理数据，处理速度快

* 缓冲区
    * 所有数据都是用缓冲区处理。任何时候访问 NIO 中的数据，都是将它放到缓冲区中。
    * 实质上是一个数组。都继承自 Buffer
        * ByteBuffer 字节数组
        * CharBuffer
        * ShortBuffer
        * IntBuffer
        * LongBuffer
        * FloatBuffer
        * DoubleBuffer
* 通道
    * Channel，通过它读写数据
    * 通道是双向的，而流是单向的（InputStream 或 OutputStream）
* 读写
```java
// 复制文件
buffer.clear(); //重设缓冲区
int r = fcin.read(buffer); // 读入数据到缓冲区

if(r == -1){
    break;
}

buffer.flip(); // 让缓冲区可以将新读入的数据写入另一个通道
fcout.write(buffer); // 写入缓冲区
```

## 网络编程

### OSI 七层模型

#### 应用层

直接向用户提供服务，完成用户希望在网络上完成的各种工作。

* 用户接口：应用层是用户与网络，以及应用程序与网络间的直接接口，使得用户能够与网络进行交互式联系。
* 实现各种服务：该层具有的各种应用程序可以完成和实现用户请求的各种服务。
    
#### 表示层

“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等

* 数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异。
* 数据的编码：处理字符集和数字的转换。例如由于用户程序中的数据类型（整型或实型、有符号或无符号等）、用户标识等都可以有不同的表示方式，因此，在设备之间需要具有在不同字符集或格式之间转换的功能。
* 压缩和解压缩：为了减少数据的传输量，这一层还负责数据的压缩与恢复。
* 数据的加密和解密：可以提高网络的安全性。

#### 会话层

组织和协调两个会话进程之间的通信，并对数据交换进行管理。

* 会话管理：允许用户在两个实体设备之间建立、维持和终止会话，并支持它们之间的数据交换。例如提供单方向会话或双向同时会话，并管理会话中的发送顺序，以及会话所占用时间的长短。
* 会话流量控制：提供会话流量控制和交叉会话功能。
* 寻址：使用远程地址建立会话连接。l
* 出错控制：从逻辑上讲会话层主要负责数据交换的建立、保持和终止，但实际的工作却是接收来自传输层的数据，并负责纠正错误。会话控制和远程过程调用均属于这一层的功能。但应注意，此层检查的错误不是通信介质的错误，而是磁盘空间、打印机缺纸等类型的高级错误。

#### 传输层

向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。

* **传输连接管理**：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务。
* **处理传输差错**：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发。
* **监控服务质量**。

#### 网络层

通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。

* **寻址**：数据链路层中使用的物理地址（如MAC地址）仅解决网络内部的寻址问题。在不同子网之间通信时，为了识别和找到网络中的设备，每一子网中的设备都会被分配一个唯一的地址。由于各子网使用的物理技术可能不同，因此这个地址应当是逻辑地址（如IP地址）。
* **交换**：规定不同的信息交换方式。常见的交换技术有：线路交换技术和存储转发技术，后者又包括报文交换技术和分组交换技术。
* **路由算法**：当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。
* **连接服务**：与数据链路层流量控制不同的是，前者控制的是网络相邻节点间的流量，后者控制的是从源节点到目的节点间的流量。其目的在于防止阻塞，并进行差错检测。

#### 数据链路层

通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层。

#### 物理层

利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。

### 协议

* 应用层
    * 远程登录协议 Telnet
    * 文件传输协议 FTP
    * 超文本传输协议 HTTP
    * 域名服务 DNS
    * 简单的邮件传输协议 SMTP
    * 邮局协议 POP3

* 传输层
    * 传输控制协议 TCP
    * 用户数据报协议 UDP

* 网络层
    * 忘记协议 IP
    * Internet 互联网控制报文协议 ICMP
    * Internet 组管理协议 IGMP
    *
    
参考：http://blog.csdn.net/yaopeng_2005/article/details/7064869


### TCP 与 UDP 区别

* TCP 是面向连接的可靠传输协议，能够提供两台计算机间的可靠的数据流（HTTP、FTP、Telnet）。传输效率比 UDP 低。三次握手原则
* UDP 是一种无连接的协议，每个数据报都是独立的信息，并不保证数据报是否能正确的到达目的地。

TCP 三次握手连接

* 主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B，向主机B请求建立连接。
    主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我.
* 主机B收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A.
    也告诉主机A两件事：我已经收到你的请求了,你可以传输数据了；你要用哪佧序列号作为起始数据段来回应我
* 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B的数据段:"我已收到回复,我现在要开始传输实际数据了
这样3次握手就完成了,主机A和主机B 就可以传输数据了.

TCP 四次握手断开

* 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
* 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
* 由B端再提出反方向的关闭请求,将FIN置1
* 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.


### Socket

基于 TCP/IP 协议

* 创建 Socket

```java
// 客户端
Socket socket = new Socket("ipaddress", port);
// 服务端
ServerSocket server = new ServerSocket(port);
```

* 打开连接到 Socket 的输入/输出流
* 对 Socket 进行读写操
* 关闭 Socket


## 反射

reflection 






    